from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import json
import re
from app.llm import ask_model
from app.db_utils import query_db
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

load_dotenv()

app = FastAPI(title="BI-GPT Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # для фронтенда
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class AskRequest(BaseModel):
    question: str

# Простая проверка безопасности SQL
def safe_sql(sql: str) -> bool:
    forbidden = ["insert", "update", "delete", "drop", "alter", "create"]
    sql_lower = sql.lower()
    return sql_lower.startswith("select") and not any(f in sql_lower for f in forbidden)

@app.get("/ping")
def ping():
    return {"status": "ok"}

@app.post("/ask")
def ask(req: AskRequest):
    raw = ask_model(req.question)

    # Попробуем распарсить JSON
    try:
        payload = json.loads(raw)
        sql = payload.get("sql", "").strip()
        explain = payload.get("explain", "")
    except Exception:
        sql = raw.strip()
        explain = ""

    if not sql:
        raise HTTPException(status_code=400, detail="No SQL generated by model")

    # Проверка безопасности
    if not safe_sql(sql):
        raise HTTPException(status_code=400, detail="Unsafe SQL: only SELECT queries allowed")

    # Добавляем LIMIT, если его нет
    if "limit" not in sql.lower():
        sql = re.sub(r";\s*$", "", sql)  # убираем ; на конце
        sql += " LIMIT 1000"

    try:
        rows = query_db(sql)
        return {"sql": sql, "explain": explain, "data": rows}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
